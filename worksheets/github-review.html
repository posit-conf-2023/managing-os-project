<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Github issue process</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="github-review_files/libs/clipboard/clipboard.min.js"></script>
<script src="github-review_files/libs/quarto-html/quarto.js"></script>
<script src="github-review_files/libs/quarto-html/popper.min.js"></script>
<script src="github-review_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="github-review_files/libs/quarto-html/anchor.min.js"></script>
<link href="github-review_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="github-review_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="github-review_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="github-review_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="github-review_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Github issue process</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>These are some ideas for reviewing github issues</p>
<p><strong>GitHub issue process</strong></p>
<section id="motivation" class="level1">
<h1><strong>Motivation</strong></h1>
<ul>
<li><p>Want to look at each issue the fewest possible number of times. The process should be designed to avoid re-reading issues.</p></li>
<li><p>The GitHub issues interface makes it hard to work with &gt;25 issues at once. The process should be designed to narrow down to &lt;25 related issues.</p></li>
<li><p>GitHub notifications are ephemeral and hard to manage. The process should allow you to ignore notifications without guilt, knowing that you will see them again at the right time.</p></li>
</ul>
</section>
<section id="issue-triage" class="level1">
<h1><strong>Issue triage</strong></h1>
<p>Issue triage ensures that every issue has a minimal reprex that allows you to understand and recreate the problem.</p>
<section id="reprex" class="level2">
<h2 class="anchored" data-anchor-id="reprex">Reprex</h2>
<p>If an issue does not have a reprex, add the label <strong>reprex</strong> and include the reprex saved reply:</p>
<blockquote class="blockquote">
<p>Can you please provide a minimal reprex (reproducible example)? The goal of a reprex is to make it as easy as possible for me to recreate your problem so that I can fix it: please <a href="https://nypdecider.files.wordpress.com/2014/08/help-me-help-you.gif">help me help you!</a></p>
<p>If you’ve never heard of a reprex before, start by reading “<a href="https://github.com/jennybc/reprex#what-is-a-reprex">What is a reprex</a>”, and follow the advice further down that page.</p>
</blockquote>
<p>If an issue does not have a reprex after 7 days, close it with the no-reprex saved reply:</p>
<blockquote class="blockquote">
<p>I’ve closed this issue due to lack of requested reprex. If you still care about this bug, please open a new issue with a reprex.</p>
<p>If the reprex is not minimal, or it’s not clear what the problem is, engage with the user. It’s tempting to be curt because you have so many issues to process, but generally you’ll save time in the long run if you carefully explain how the issue could be improved, and how it helps you.</p>
</blockquote>
<p><br>
</p>
</section>
<section id="labels" class="level2">
<h2 class="anchored" data-anchor-id="labels">Labels</h2>
<p>Once the issue has a reprex it needs be labelled with a “type” and (optionally) an “area”:</p>
<ul>
<li><p>There are three main types: <strong>bug</strong> (#e02a2a), <strong>feature</strong> (#009800), and <strong>docs</strong> (#0052cc).</p></li>
<li><p>Each repo will have different areas. These will evolve over time as it becomes more clear what the key pieces of the package are. This type of label is particularly important when there are &gt;25 issues as it makes it much easier to find duplicates.</p></li>
<li><p>usethis::use_github_labels() lets you use all standard tidyverse labels are present for your repo and set to standard colors. It does not clobber existing labels unless you ask and even then it is very conservative. usethis::tidy_labels() shows current defaults.</p></li>
</ul>
</section>
<section id="one-to-one" class="level2">
<h2 class="anchored" data-anchor-id="one-to-one">One-to-One</h2>
<p>Each issue should encapsulate one problem. There are two common exceptions:</p>
<ul>
<li><p>One issue represents multiple problems. Either the original author bundled together multiple problems, or later commenters have added problems that they think are related (but aren’t). Either way, you’re better off creating one new issue for each problem and closing the current issue.</p></li>
<li><p>One problem appears in multiple issues. In this case, create a new meta-issue that links to all the existing issues, then close the old issues leaving only the meta issue open.</p></li>
</ul>
<p>These problems tend to be more pronounced in repos that have been lying fallow for some time.</p>
</section>
</section>
<section id="github-projects" class="level1">
<h1><strong>GitHub projects</strong></h1>
<p>Use projects to ensure that you have a clear “next task”, and you have a single priority ranking at any given time.</p>
<p>A project should be associated with a person (i.e.&nbsp;named according to their GitHub username), and should have (at least) three columns:</p>
<ul>
<li><p><strong>To do:</strong> an ordered list of issues which you can tackle next.</p></li>
<li><p><strong>Blocked:</strong> an issue that you’ve started working on, but input from someone else before you can continue on it.</p></li>
<li><p><strong>Done:</strong> this is mostly here for psychological satisfaction.</p></li>
</ul>
</section>
<section id="weekly-review-of-active-projects" class="level1">
<h1><strong>Weekly review of active projects</strong></h1>
<p>Once a week:</p>
<ul>
<li><p>Triage all new issues (i.e.&nbsp;all issues without labels)</p></li>
<li><p>Process all issues that need a reprex (either gently prodding or closing)</p></li>
<li><p>Review all issues (or large projects issues with a given label) and add specified issues to your to do list.</p></li>
</ul>
<p>This ensures that it’s always clear what you should do next, while minimising the time spent re-reading issues. You either think about what you should be working, or steadily work down a list of issues: you are not required to context switch between the two modes. You can ignore notifications without guilt, because you know you will see the issues again in the future.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>